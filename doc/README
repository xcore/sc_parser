The module_compparser provides functions to build parsers based on a custom grammar.

Usually recursive descent parsers are hard coded and generated by some parser generator or handwritten. 
The approach here let the programmer focus on the syntax, defined by a grammar, that a source data need to match 
skipping the step of code generation. This makes changes easier and reduces errors.
The parser engine is the module: “CompParser.c” and the related interface: “CompParser.h”;
it implements an LL(k) recursive descent parser. It need never be edited, only exception could be the directive 
“#pragma stackfunction 2000”. It might be necessary to increase stack size for the following recursive function 
if grammar and/or source data are particularly complex although usually this is symptom of a left recursion in the grammar.

The parsing function:
int StartParse( const unsigned char Grammar[], FREAD SourceRead, F_ACTION *ActFunc[])
requires as input: a buffer with the compiled binary grammar; a function for reading the source data;
a vector of function pointers (action functions) that will be called during the parsing process when specified by the grammar.
Return value is PASS if source matches the grammar syntax rules, FAIL otherwise.

Parsing function uses a compiled grammar for speed optimization purpose, this makes the parser as fast as an hardcoded one.
But compiled grammar is difficult to write so the module “EbnfGrammarCompiler” is provided. 
The “EbnfGrammarCompiler” function needs a function for reading a source “EBNF like” grammar; 
a vector (and its length) of the names used in the EBNF grammar to identify the action functions;
a function for writing the compiled grammar.
Beware that the action names list must be sorted in the same order as ActFunc passed later to the Parse function.

“EbnfGrammarCompiler” module need never to be edited but in the "CompParserConf.h" you need to set the
EBNF_GRAMMAR_COMPILER_SYM_SIZE more than the number of syntax rules defined in the ebnf grammar and
EBNF_GRAMMAR_COMPILER_STACK_SIZE more than the maximun number of nested parentheses in the ebnf grammar.

The “EbnfGrammarCompiler” function itself is a sample of usage of the parser function because it calls the parsing engine 
and a readymade compiled grammar of the EBNF grammar to convert the source EBNF grammar into a compiled binary grammar.

EbnfGrammarCompiler module needs not to be included in a parser project, the grammar could be compiled once and then 
the output of compilation could be embedded or downloaded runtime.

The grammar for the grammar compiler is in an EBNF like format because uses extensions which are not standard.
For example usually optional objects (object that can be present 0 or 1 time) are enclosed into square brackets, 
multiple optional objects ( present 0 up to infinite times) are enclosed in curly brackets. 
In my grammar the number of “must” times and, optionally, the number of maximum times, is an unary operator that applies 
to the next object. So for example a rule like:
Rule = 3( 'a', 1~2'b');
Parses successfully the sequence “abbababb” or “abababb”, or... 

Following rule:
DecInteger = 1~6DecDigit; 
Defines DecInteger as a syntax rule that checks a sequence of at least 1 up to 6 DecDigit (elsewhere defined).
Maximum times can be ? for infinite. Using standard EBNF syntax the rule above would be written:
DecInteger = DecDigit, [DecDigit, [DecDigit, [DecDigit, [DecDigit, [DecDigit]]]]];

Note, the rule:
A = 1~?'a';		*
Is equivalent to standard EBNF rule:
A = <'a'>;
Such rule could be defined not using extension but only standard BNF syntax with a recursive definition:
A = 'a', A;		**
Note: writing A = A, 'a'; would be left recursive and cause the parser to crash for stack overflow.
Left recursion could be detected when compiling grammar but it is not done in this release.
It is suggested not to use recursive rules like ** and replace with rules like * because they are stack consuming and slower.
In particular ** would nest calls as long as 'a' are read from source.
Another extension of the BNF syntax is the char range definition. Following example parses any char between 0 and 9.
DecDigit = '0':'9';

Chars in a terminal string can be escaped, this is necessary for \ and ‘ chars that must be written as \\ and \'.
The \ can be followed by 2 hex digits to represent any byte code.

The & and ! unary operator act on the following object. They cause not to reduce (advance) the source this means that 
after checking the object the source position is restored to the original one. 
The ! operator negates the result returned by next object. Here some self-explaining sample:
UppercaseVovel = &Vovel, Uppercase;
UppercaseConsonant = !Vovel, Uppercase;
Vovel = 'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U';
UpperCase = 'A':'Z';.

Grammar can be ‘decorated’ with actions. Actions are symbols not present in the grammar itself but refer to functions that will be 
provided to the parser engine when using the grammar. Like a syntax rule an action function can PASS or FAIL. 
The grammar can define a parameter string that will be received by the function. Example:
A = 'A', @IsA=The source is an A\00@
Action names must be listed in a vector to be passed to the grammar compiler. 
The compiled grammar will refer to the action function not by its name but by the index position in the list.
Later, when the compiled grammar is passed to the parser, a vector of action function pointers need to be passed too.
The parser will call the functions using the index in the vector.

If USE_INCR_COMPPARSER is defined in "CompParserConf.h" then an incremental version of the parser will be used.
It has a pre-defined action function (@Yield@) which causes the parser function return to the caller keeping the internal state.
Then the parsing can be resumed by calling the ContinueParse function. It can be usefull for parsing streams.

Parsing algorithm: the parser starts checking the first syntax rule which in turn may refer to other ones.
A syntax rule is made of one or more alternatives separated by |. 
The parser tries the alternatives till finding a matching one, in this case the rule passes.
Each alternative is a sequence of many  unary expression separated by commas. 
The unary expressions are checked left to right when an unary fails the alternative fails too.
Unary expression are unary operators followed by primary ( i.e. sub syntax rules surrounded by round brackets, 
references to other rules, action, terminal strings or char range ).
An alternative can also be empty, in this case it always passes thus next alternatives won’t be checked.
Empty alternative is meaningful only if last one.


The app_expression_parser application is sample code that uses the module functions to implement an expression calculator.
( running into the simulator may take 2 or 3 minutes to compile the grammar and a few seconds to parse the expression).

The app_xml_parser is application is sample code that uses the module functions to build a tree structure based on
an xml source. Xml grammar (derived from http://www.w3.org) has been modified to manage only 1byte charset.
A few ambiguous rules corrected. Then decorated with actions to build the tree of elements.
maximum number of elements is defined by: #define MAX_ELEMENTS 100
maximum number of nested element is defined by: #define MAX_NESTED_ELEMENTS 20
Todo: 
-empty elements ( elements without content ) are not traced.
-attributes of element are not include in the element node structure
-could avoid the final sorting of the elements if the ELEMENT structure had vector of pointers to child elements
instead of just a vector of child elements but would waste a little more memory ( 1 pointer more for each element )

